<!DOCTYPE html>
<html lang="en">
<head>

  <title>A Quick Dive In To Regular Expressions &mdash; Randson Oliveira</title>

  <!-- Meta -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="Randson Oliveira">
  <meta name="application-name" content="Randson Oliveira">
  <meta name="theme-color" content="#FEFEFE">

  <!-- Facebook -->
  <meta property="og:title" content="A Quick Dive In To Regular Expressions &mdash; Randson Oliveira">
  <meta property="og:site_name" content="Randson Oliveira">
  <meta property="og:url" content="http://rands0n.com/a-quick-dive-in-to-regular-expressions/">
  <meta property="og:type" content="blog">
  <meta property="og:image" content="/images/rands0n.jpg">
  <meta property="og:description" content="">

  <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <!-- Favicon -->
  <link rel="shortcut icon" href="/images/rands0n.jpg">

  <!-- Feed -->
  <link rel="alternate" type="application/rss+xml" href="index.xml">

  <!-- Stylesheets -->
  <link rel="stylesheet" href="/css/main.css">
</head>
<body class="post">
  <div class="container">
    <h1 class="site-title">
      <a href="/">Randson Oliveira</a>

      
        &raquo;

        A Quick Dive In To Regular Expressions
      
    </h1>


<div class="post post-page">
  <div class="post-meta">
    <time
      class="post-meta-date"
      datetime="2016-01-29 00:00:00 -0200">
      January 29, 2016
    </time>
    <!-- /post-meta-date -->

    &mdash;

    <span
      class="read-time"
      title="Estimate read time"
      alt="Estimate read time">
      
      13 min read
    </span>
  </div>
  <!-- /post-meta -->

  <div class="post-content">
    <p class="availables">
    Also available in <a href="https://medium.com/codeminer-42/um-r%C3%A1pido-mergulho-em-express%C3%B5es-regulares-e8e52c5b247c">Portuguese</a>.
</p>

<p>Hello, how about forgetting a little routine and reality and take a trip to the interior of your mind? Discover new, different concepts. When go back, things will not be as normal as before because strangest symbols will be part of your day-to-day life.</p>

<p>Inspired by operating their own neurons, discover the fascinating world of Regular Expressions.</p>

<h2 id="presenting">Presenting</h2>

<p>So, in order to start our trip, nothing like a presentation of the subject, because, after all, what’s Regular Expression?</p>

<p>Well sumerized, regular expression is a formal method to specify a text pattern.</p>

<p>More detailed, is a composition of symbols, characters with a special function, which grouped among themselves and with literal characters form a sequence, a expression. This is expression is interpreted as a rule that indicates a success or failure depending on the input. It’s exactly all the conditions of the expression.</p>

<p>Or as accepted variations also can be said that is:</p>

<ul>
  <li>a way to find a text that you do not remember exactly how, but have no idea of possible variations;</li>
  <li>a way for a programmer to specify complex patterns that can be searched and married in a string;</li>
</ul>

<p>Or formally speaking is:</p>

<ul>
  <li>as a game, in the begining it’s difficult, but after knowing all the rules, just play and enjoy;</li>
  <li>as a recipe with ingredients and a proper order to add them to the mixture;</li>
</ul>

<p>Above all, a Regular Expression is <strong>fun</strong>.</p>

<h2 id="the-history">The History</h2>

<p>Regular expressions are originated in 1956, when mathematician <a href="https://en.wikipedia.org/wiki/Stephen_Cole_Kleene">Stephen Cole Kleene</a> described <a href="https://en.wikipedia.org/wiki/Regular_language">regular languages</a> using his mathematical notation called <em>regular sets</em>. These arose in <a href="https://en.wikipedia.org/wiki/Theoretical_computer_science">theorical computer science</a>, in the subfields of <a href="https://en.wikipedia.org/wiki/Automata_theory">automata theory</a>(models of computation) and the description and classification of <a href="https://en.wikipedia.org/wiki/Formal_language">formal languages</a>. Other early implementations of <a href="https://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a> include the <a href="https://en.wikipedia.org/wiki/SNOBOL">SNOBOL</a> language, which did not use regular expressions, but instead its own pattern matching constructs.</p>

<blockquote>
  <p>Quickly introduction from <a href="https://en.wikipedia.org/wiki/Regular_expression">Wikipedia’s</a>.</p>
</blockquote>

<p><img src="/images/posts/history.png" style="margin: 0 auto;" alt="persons who brought regex|re" /></p>

<p>In 1968, the UNIX pioneer <em>Ken Thompson</em> published the article <a href="http://www.fing.edu.uy/inco/cursos/intropln/material/p419-thompson.pdf">Regular Expression Search Algorithm</a> in Communications of the ACM (CACM), Volume 11. With code and prose he described a Regular Expression compiler that creates a IBM 7094 Object code. Thompson’s effort did not end there. He also implemented Kleene’s notation in the editor <code class="highlighter-rouge">QED</code>. The aim was that the user could do advanced pattern matching in the files. The same feature appeared on the editor <code class="highlighter-rouge">ed</code>.</p>

<p>To search for a Regular Expression in <code class="highlighter-rouge">ed</code> you wrote <code class="highlighter-rouge">g/&lt;regular expression&gt;/p</code>. The letter <code class="highlighter-rouge">g</code> means global search and <code class="highlighter-rouge">p</code> are print the result. The command - <code class="highlighter-rouge">g/re/p</code> resulted in the standalone program <code class="highlighter-rouge">grep</code>, released in the fourth edition of UNIX 1973. However, <code class="highlighter-rouge">grep</code> didn’t have a complete implementation of regular expressions, and it was no until 1979, in the seventh edition of UNIX the we were blessed with Alfred Aho’s <code class="highlighter-rouge">egrep</code> - <em>extended grep</em>. Now the circle was closed. The <code class="highlighter-rouge">egrep</code> program translated any regular expression to a corresponding DFA.</p>

<p><img src="/images/posts/perl_problems.png" style="margin: 0 auto;" alt="wtf is regular expression?" /></p>

<div class="alt">
    Some people, when confronted with a problem, think I know, I’ll use regular expressions. Now they have two problems. <i>Jamie Zawinski</i>
</div>

<p>It’s totally true if you do not pratice regex. In a very short period of time you’ll forget many of things to use. However, it’s totally understandable if you not use it everyday. Most of us do not use.</p>

<hr />

<p>Regular Expressions are both terribly awkward and extremely useful. But they are a powerful tool for inspecting and processing strings. Properly understanding regular expressions will make you a more effective programmer.</p>

<h2 id="the-notation">The Notation</h2>

<p>If you are using regex on a programming language. In JavaScript for example a regular expression is a type of an Object. In many cases, you can create a new regex by simple put slash <code class="highlighter-rouge">/&lt;regex&gt;/</code> to start write.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">/abc/</code></pre></figure>

<p>Where the pattern appears between slash characters, treats backslashes somewhat differently. First, since a forward slash ends the pattern, we need to put a backslash before any forward slash that we want to be part of the pattern. In addition, backslashes that aren’t part of special character codes (like <code class="highlighter-rouge">\n</code>) will be <em>preserved</em>, rather than ignored as they are in strings, and change the meaning of the pattern. Some characters, such as question marks and plus signs, have special meanings in regular expressions and must be preceded by a backslash if they are meant to represent the character itself.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">/eighteen<span class="se">\+</span>/</code></pre></figure>

<p>Knowing precisely what characters to backslash-escape when writing regular expressions requires you to know every character with a special meaning. For the time being, this may not be realistic, so when in doubt, just put a backslash before any character that is not a letter, number, or whitespace.</p>

<h2 id="testing-by-matches">Testing By Matches</h2>

<p>It’s more easily to find your pattern testing by a match. When you want one word, first take your firsts characters and improve you pattern to find what you want.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="se">\d</span>+ <span class="c">#=&gt; 123456789</span></code></pre></figure>

<p>The website I recommend to use is <a href="http://regex101.com/">regex101.com</a>. You can put a string by example and test your pattern through test string below.</p>

<figure class="highlight"><pre><code class="language-linenos" data-lang="linenos">/[123456789]+/ # "In 1992" #=&gt; 1992
/[0-9]+/ # "In 1992" #=&gt; 1992
/\d+/ # "In 1992" #=&gt; 1992</code></pre></figure>

<p>Within square brackets, a dash (<code class="highlighter-rouge">-</code>) between two characters can be used to indicate a range of characters, where the ordering is determined by the character’s Unicode number. Characters 0 to 9 sit right next to each other in this ordering (codes 48 to 57), so <code class="highlighter-rouge">[0-9]</code> covers all of them and matches any digit.</p>

<p>There are a number of common character groups that have their own built-in shortcuts. Digits are one of them: <code class="highlighter-rouge">\d</code> means the same thing as <code class="highlighter-rouge">[0-9]</code>.</p>

<ul>
  <li><code class="highlighter-rouge">\d</code> - Any digit character</li>
  <li><code class="highlighter-rouge">\w</code> - An alphanumeric character (“word character”)</li>
  <li><code class="highlighter-rouge">\s</code> - Any whitespace character (space, tab, newline, and similar)</li>
  <li><code class="highlighter-rouge">\D</code> - A character that is not a digit</li>
  <li><code class="highlighter-rouge">\W</code> - A nonalphanumeric character</li>
  <li><code class="highlighter-rouge">\S</code> - A nonwhitespace character</li>
  <li><code class="highlighter-rouge">.</code> - Any character except for newline</li>
</ul>

<p>So you could match the date format with the following pattern:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">/<span class="se">\d\d</span>-<span class="se">\d\d</span>-<span class="se">\d\d\d\d</span> <span class="se">\d\d</span>:<span class="se">\d\d</span>/ <span class="c">#=&gt; 29-01-2016 15:20</span></code></pre></figure>

<p>That’s look completely awful, doesn’t it? It has way too many backslashes, producing background noise that makes it hard to spot the actual pattern expressed. We’ll see a slightly improved version of this pattern using range <code class="highlighter-rouge"><span class="p">{}</span></code>.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">/<span class="o">(</span><span class="se">\d</span><span class="o">{</span>1,2<span class="o">}</span>-<span class="se">\d</span><span class="o">{</span>1,2<span class="o">}</span>-<span class="se">\d</span><span class="o">{</span>4<span class="o">})</span> <span class="o">(</span><span class="se">\d</span><span class="o">{</span>1,2<span class="o">}</span>:<span class="se">\d</span><span class="o">{</span>2<span class="o">})</span>/ <span class="c">#=&gt; 29-01-2016 15:20</span></code></pre></figure>

<p>Don’t be scared with the pattern we’ve used above. Analysing the string by parts, we can understand what she does. First we need find groups <code class="highlighter-rouge">()</code>, the groups are used to break your pattern in parts. Let’s understand the pattern by parts. In pattern above, we have 2 groups, a date and a time <code class="highlighter-rouge">(\d{1,2}-\d{1,2}-\d{4})</code> - <code class="highlighter-rouge">(\d{1,2}:\d{2})</code>. By make this we break the pattern in two parts, now take the first part to break in another parts. Let’s get the part <code class="highlighter-rouge">\d{1,2}</code> what do you think it does? It’s exactly what you think. He’ll take exactly two number of string. Understanding this you can understand others parts.</p>

<p>These backslash codes can also be used inside square brackets. For example, <code class="highlighter-rouge">[\d.]</code> means any digit or a period character. But note that the period itself, when used between square brackets, loses its special meaning. The same goes for other special characters, such as <code class="highlighter-rouge">+</code>.</p>

<p>To invert a set of characters—that is, to express that you want to match any character <em>except</em> the ones in the set—you can write a caret (<code class="highlighter-rouge">^</code>) character after the opening bracket.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">/[^<span class="se">\d</span><span class="o">]</span>/</code></pre></figure>

<h2 id="repeting-parts-of-a-pattern">Repeting Parts of a Pattern</h2>

<p>We now know how to match a single digit. What if we want to match a whole number—a sequence of one or more digits?</p>

<p>When you put a plus sign (<code class="highlighter-rouge">+</code>) after something in a regular expression, it indicates that the element may be repeated more than once. Thus, <code class="highlighter-rouge">/\d+/</code> matches one or more digit characters.</p>

<figure class="highlight"><pre><code class="language-linenos" data-lang="linenos">/\d+/ # 123 #=&gt; true
/\d+/ # '' #=&gt; false
/\d*/ # 123 #=&gt; true
/\d*/ # '' #=&gt; true</code></pre></figure>

<p>The star (<code class="highlighter-rouge">*</code>) has a similar meaning but also allows the pattern to match zero times. Something with a star after it never prevents a pattern from matching—it’ll just match zero instances if it can’t find any suitable text to match.</p>

<h2 id="making-characters-optional">Making characters optional</h2>

<p>A question mark makes a part of a pattern “optional”, meaning it may occur zero or one time. In the following example, the <em>u</em> character is allowed to occur, but the pattern also matches when it’s missing.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">/neighbou?r/ <span class="c"># neighbor #=&gt; true</span></code></pre></figure>

<h2 id="grouping-subexpression">Grouping Subexpression</h2>

<p>To use an operator like <code class="highlighter-rouge">*</code> or <code class="highlighter-rouge">+</code> on more than one element at a time, you can use parentheses. A part of regular expression that is enclosed in parentheses counts as a single element as far as the operators following it are concerned.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">/boo+<span class="o">(</span>hoo+<span class="o">)</span>+/i <span class="c">#=&gt; Boohoooohoohooo</span></code></pre></figure>

<p>The first and second <code class="highlighter-rouge">+</code> characters apply only to the second <code class="highlighter-rouge">o</code> in <code class="highlighter-rouge">boo</code> and <code class="highlighter-rouge">hoo</code>, respectively. The third <code class="highlighter-rouge">+</code> applies to the whole group <code class="highlighter-rouge">(hoo+)</code>, matching one or more sequences like that.</p>

<p>The <code class="highlighter-rouge">i</code> at the end of the expression in the previous example makes this regular expression case insensitive, allowing it to match the uppercase <code class="highlighter-rouge">B</code> in the input string, even though the pattern is itself all lowercase.</p>

<h2 id="choice-patterns">Choice Pattern’s</h2>

<p>So we want to know whether a piece of text contains not only a number but a number followed by one of the words <code class="highlighter-rouge">cow</code>, <code class="highlighter-rouge">table</code> or <code class="highlighter-rouge">mail</code> and any other plural form of this words.</p>

<p>We could write tree regex to find this words, but there’s a nicer way. The pipe character (<code class="highlighter-rouge">|</code>) denotes a choice between the pattern to its left and the pattern to its right. So I can say this:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">/<span class="se">\b\d</span>+ <span class="o">(</span>cow|table|mail<span class="o">)</span>s?<span class="se">\b</span>/</code></pre></figure>

<p>Parentheses can be used to limit the part of the pattern that the pipe operator applies to, and you can put multiple such operators next to each other to express a choice between more than two patterns.</p>

<h2 id="the-mechanics-of-matching">The mechanics of matching</h2>

<p>Regular expressions can be thought of as flow diagrams. This is the diagram for the livestock expression removed from <a href="http://eloquentjavascript.net/09_regexp.html">Eloquent Javascript Book’s</a>. And I recommend you to read the section on book if you want to know how to use regex with JS.</p>

<p>The following example is removed from the book because this is a good example to know about the mechanics of matching.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">/<span class="se">\b\d</span>+ <span class="o">(</span>ping|cow|chicken<span class="o">)</span>s?<span class="se">\b</span>/
<span class="s2">"15 pigs"</span> <span class="c">#=&gt; true</span>
<span class="s2">"15 pigchickens"</span> <span class="c">#=&gt; false</span></code></pre></figure>

<p><img src="/images/posts/mechanism_of_matching.svg" style="margin: 0 auto;" /></p>

<p>Our expression matches a string if we can find a path from the left side of the diagram to the right side. We keep a current position in the string, and every time we move through a box, we verify that the part of the string after our current position matches that box.</p>

<p>So if we try to match “the 3 pigs” with our regular expression, our progress through the flow chart would look like this:</p>

<ul>
  <li>At position 4, there is a word boundary, so we can move past the first box.</li>
  <li>Still at position 4, we find a digit, so we can also move past the second box.</li>
  <li>At position 5, one path loops back to before the second (digit) box, while the other moves forward through the box that holds a single space character. There is a space here, not a digit, so we must take the second path.</li>
  <li>We are now at position 6 (the start of “pigs”) and at the three-way branch in the diagram. We don’t see “cow” or “chicken” here, but we do see “pig”, so we take that branch.</li>
  <li>At position 9, after the three-way branch, one path skips the s box and goes straight to the final word boundary, while the other path matches an s. There is an s character here, not a word boundary, so we go through the s box.</li>
  <li>We’re at position 10 (the end of the string) and can match only a word boundary. The end of a string counts as a word boundary, so we go through the last box and have successfully matched this string.</li>
</ul>

<p>Conceptually, a regular expression engine looks for a match in a string as follows: it starts at the start of the string and tries a match there. In this case, there is a word boundary there, so it’d get past the first box—but there is no digit, so it’d fail at the second box. Then it moves on to the second character in the string and tries to begin a new match there… and so on, until it finds a match or reaches the end of the string and decides that there really is no match.</p>

<h2 id="summary">Summary</h2>

<p>Regular expressions are objects that represent patterns in strings. They use their own syntax to express these patterns.</p>

<ul>
  <li><code class="highlighter-rouge">/abc/</code> - A sequence of characters</li>
  <li><code class="highlighter-rouge">/[abc]/</code> - Any character from a set of characters</li>
  <li><code class="highlighter-rouge">/[^abc]/</code> - Any character not in a set of characters</li>
  <li><code class="highlighter-rouge">/[0-9]/</code> - Any character in a range of characters</li>
  <li><code class="highlighter-rouge">/x+/</code> - One or more occurrences of the pattern x</li>
  <li><code class="highlighter-rouge">/x+?/</code> - One or more occurrences, nongreedy</li>
  <li><code class="highlighter-rouge">/x*/</code> - Zero or more occurrences</li>
  <li><code class="highlighter-rouge">/x?/</code> - Zero or one occurrence</li>
  <li><code class="highlighter-rouge">/x{2,4}/</code> - Between two and four occurrences</li>
  <li><code class="highlighter-rouge">/(abc)/</code> - A group</li>
  <li><code class="highlighter-rouge">/a|b|c/</code> - Any one of several patterns</li>
  <li><code class="highlighter-rouge">/\d/</code> - Any digit character</li>
  <li><code class="highlighter-rouge">/\w/</code> - An alphanumeric character (“word character”)</li>
  <li><code class="highlighter-rouge">/\s/</code> - Any whitespace character</li>
  <li><code class="highlighter-rouge">/./</code> - Any character except newlines</li>
  <li><code class="highlighter-rouge">/\b/</code> - A word boundary</li>
  <li><code class="highlighter-rouge">/^/</code> - Start of input</li>
  <li><code class="highlighter-rouge">/$/</code> - End of input</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>This is a quickly introduction about Regular Expressions. Still has much to learn about and discover new things to use in your day-to-day life. I hope you enjoy this post and we’ll see in the next’s posts about regex.</p>

  </div>
  <!-- /post-content -->
</div>
<!-- /post post-page -->

<h3>About Randson Oliveira</h3>

<div>
  <img src="/images/rands0n.jpg" style="width: 150px; float: left; margin: 0 1.4em 1.4em 0;" alt="">

  <p>
    Hey! I'm a developer trying building some rock solid systems using Javascript and Ruby. Besides programming I enjoy music and video games.
  </p>

  <p>
    I'd love to hear your questions and comments on this article! <a href="https://twitter.com/rands0n">Mention me on twitter</a> or <a href="mailto:orandson@gmail.com">shoot me an email</a>.
  </p>
</div>


    <div class="footer">
      ----<br>
      Copyright 2016 <a href="/">Randson Oliveira</a>, Powered by <a href="http://jekyllrb.com">Jekyll</a>.
    </div>

  </div>
  <!-- /container -->

</body>
</html>

